-- LAB 3
-- Assignment 5
-- Time:

module Ass5 where
import Ass1
import Ass3
import Ass4
import Data.List
import HelperCodeLab3
import System.Random
import System.IO.Unsafe
import Test.QuickCheck
import SetOrd


-- How can you prove that the sub implementation is correct?
-- We can prove the sub implementation is correct by formulating properties of subsets
-- and testing if these properties are True.
-- From wikipedia we can obtain the following propertiesâˆ·

-- A set X is a subset of Y if and only if their intersection is equal to X.
-- A set X is a subset of Y if and only if their union is equal to Y.
-- A finite set X is a subset of Y if and only if the cardinality of their intersection is equal to the cardinality of X.


-- Test the implementation with two QuickCheck properties.



sub :: Form -> Set Form
sub (Prop x) = Set [Prop x]
sub (Neg f) = unionSet (Set [Neg f]) (sub f)
sub f@(Cnj [f1,f2]) = unionSet ( unionSet (Set [f]) (sub f1)) (sub f2)
sub f@(Dsj [f1,f2]) = unionSet ( unionSet (Set [f]) (sub f1)) (sub f2)
sub f@(Impl f1 f2) = unionSet ( unionSet (Set [f]) (sub f1)) (sub f2)
sub f@(Equiv f1 f2) = unionSet ( unionSet (Set [f]) (sub f1)) (sub f2)

form_one = Impl (Cnj [Neg (Dsj [Prop 1, Prop 2]), Prop 3]) (Prop 4)


-- Computes the exact number of sub-formulae of the formula f
nsub :: Form -> Int
nsub f = nsub' (sub f) 0

-- Loop through each sub-formula in the Set Form created by the sub method in
-- order to count the number of sub-formulae in the formula f initially provided
-- from nsub
nsub' :: Set Form -> Int -> Int
nsub' (Set []) n = n
nsub' (Set (x:xs)) n = nsub' (Set xs) (n + 1)

-- PROPERTY: A set X is a subset of Y if and only if their union is equal to Y (see testSetPropertyOne).
-- We were looking for a way to get a union of the subset (X) with the superset (Y).
-- We noticed that we could use unionSet for this, however, then we would the same function as sub uses.
-- This could mean that if the unionSet function is not working, this would not be clearly represented by
-- our tests.
-- Furthermore, we were thinking of iterating of iterating the superset by using !!!. We didn't
-- do this as we are not able to track when the superset ends.
-- Eventually, we chose to use the inSet function, which returns true when the subset is in the
-- superset. Due to the type signature of the inSet function there is no further need for iteration through
-- the superset.
-- Namely: inSet  :: (Ord a) => a -> Set a -> Bool
-- With a :: From in our case.
-- *Ass5> quickCheckTestSetPropertyOne
-- +++ OK, passed 100 tests.
-- Success {numTests = 100, labels = [], output = "+++ OK, passed 100 tests.\n"}
-- *Ass5>

testSetPropertyOne :: Form -> Bool
testSetPropertyOne f = inSet f (sub f)


quickCheckTestSetPropertyOne = quickCheckResult (\(RandomForm f) -> testSetPropertyOne f)



-- A finite set X is a subset of Y if and only if the cardinality of their intersection is equal to the cardinality of X.


-- Test
-- Custom datatype used to generate and store random forms
-- data RandomForm = RandomForm Form deriving (Show)
-- instance Arbitrary RandomForm where
--     arbitrary = do
        -- It's best not to use unsafePerformIO, but no other solution was found
        -- let f = unsafePerformIO formGenerator
        -- return (RandomForm f)



-- quickCheckTestSetProportyOne  = quickCheckResult (\(RandomForm f) -> testSetProportyOne f)


-- QuickCheck property testing for testSet
quickCheckTestSetPropertyTwo  = quickCheckResult (\(RandomForm f) -> testSetPropertyTwo f)

testSetPropertyTwo :: Form -> Bool
testSetPropertyTwo f = testSet (sub f) f

-- Test our implementation of sub by checking if all elements in form are also
-- in the set that is generated by the sub method
testSet :: Set Form -> Form -> Bool
testSet s (Prop x) = inSet (Prop x) s
testSet s (Neg x) = testSet s x
testSet s (Dsj [f, g]) = inSet (Dsj [f, g]) s && testSet' s f g
testSet s (Cnj [f, g]) = inSet (Cnj [f, g]) s && testSet' s f g
testSet s (Impl f g) = inSet (Impl f g) s && testSet' s f g && inSet f s && inSet g s
testSet s (Equiv f g) = inSet (Equiv f g) s && testSet' s f g && inSet f s && inSet g s

testSet' :: Set Form -> Form -> Form -> Bool
testSet' s f g = testSet s f && testSet s g



-- Test nsub' by getting form length
quickCheckTestNsub  = quickCheckResult (\(RandomForm f) -> testnsub' f)

testnsub' :: Form -> Bool
testnsub' f = nsub f == formLength f 0

formLength :: Form -> Int -> Int
formLength (Prop x) n = n + 1
formLength (Neg f) n = (formLength f 0) + (n + 1)
formLength (Cnj [f1,f2]) n = (formLength f1 0) + (formLength f2 0) + (n + 2)
formLength (Dsj [f1,f2]) n = (formLength f1 0) + (formLength f2 0) + (n + 2)
formLength (Impl f1 f2) n = (formLength f1 0) + (formLength f2 0) + (n + 2)
formLength (Equiv f1 f2) n = (formLength f1 0) + (formLength f2 0) + (n + 2)
