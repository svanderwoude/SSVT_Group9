-- LAB 3
-- Assignment 5
-- Time:

module Ass5 where
import Ass1
import Ass3
import Ass4
import Data.List
import HelperCodeLab3
import System.Random
import System.IO.Unsafe
import Test.QuickCheck
import SetOrd


-- How can you prove that the sub implementation is correct?
-- We can prove the sub implementation is correct by formulating properties of subsets
-- and testing if these properties are True.
-- From wikipedia we can obtain the following propertiesâˆ·

-- A set X is a subset of Y if and only if their intersection is equal to X.
-- A set X is a subset of Y if and only if their union is equal to Y.
-- A finite set X is a subset of Y if and only if the cardinality of their intersection is equal to the cardinality of X.


-- Test the implementation with two QuickCheck properties.



sub :: Form -> Set Form
sub (Prop x) = Set [Prop x]
sub (Neg f) = unionSet (Set [Neg f]) (sub f)
sub f@(Cnj [f1,f2]) = unionSet ( unionSet (Set [f]) (sub f1)) (sub f2)
sub f@(Dsj [f1,f2]) = unionSet ( unionSet (Set [f]) (sub f1)) (sub f2)
sub f@(Impl f1 f2) = unionSet ( unionSet (Set [f]) (sub f1)) (sub f2)
sub f@(Equiv f1 f2) = unionSet ( unionSet (Set [f]) (sub f1)) (sub f2)

form_one = Impl (Cnj [Neg (Dsj [Prop 1, Prop 2]), Prop 3]) (Prop 4)


-- Computes the exact number of sub-formulae of the formula f
nsub :: Form -> Int
nsub f = nsub' (sub f) 0

-- Loop through each sub-formula in the Set Form created by the sub method in
-- order to count the number of sub-formulae in the formula f initially provided
-- from nsub
nsub' :: Set Form -> Int -> Int
nsub' (Set []) n = n
nsub' (Set (x:xs)) n = nsub' (Set xs) (n + 1)


-- A set X is a subset of Y if and only if their union is equal to Y.
-- testSetProportyOne f = compare (unionSet (sub f) f) (list2set f)


-- A finite set X is a subset of Y if and only if the cardinality of their intersection is equal to the cardinality of X.


-- Test
-- Custom datatype used to generate and store random forms
-- data RandomForm = RandomForm Form deriving (Show)
-- instance Arbitrary RandomForm where
--     arbitrary = do
        -- It's best not to use unsafePerformIO, but no other solution was found
        -- let f = unsafePerformIO formGenerator
        -- return (RandomForm f)



-- quickCheckTestSetProportyOne  = quickCheckResult (\(RandomForm f) -> testSetProportyOne f)


-- QuickCheck property testing for testSet
quickCheckTestSetPropertyTwo  = quickCheckResult (\(RandomForm f) -> testSetPropertyTwo f)

testSetPropertyTwo :: Form -> Bool
testSetPropertyTwo f = testSet (sub f) f

-- Test our implementation of sub by checking if all elements in form are also
-- in the set that is generated by the sub method
testSet :: Set Form -> Form -> Bool
testSet s (Prop x) = inSet (Prop x) s
testSet s (Neg x) = testSet s x
testSet s (Dsj [f, g]) = inSet (Dsj [f, g]) s && testSet' s f g
testSet s (Cnj [f, g]) = inSet (Cnj [f, g]) s && testSet' s f g
testSet s (Impl f g) = inSet (Impl f g) s && testSet' s f g && inSet f s && inSet g s
testSet s (Equiv f g) = inSet (Equiv f g) s && testSet' s f g && inSet f s && inSet g s

testSet' :: Set Form -> Form -> Form -> Bool
testSet' s f g = testSet s f && testSet s g


-- Test nsub' by getting form length
quickCheckTestNsub  = quickCheckResult (\(RandomForm f) -> testnsub' f)

testnsub' :: Form -> Bool
testnsub' f = nsub f == formLength f 0

formLength :: Form -> Int -> Int
formLength (Prop x) n = n + 1
formLength (Neg f) n = (formLength f 0) + (n + 1)
formLength f@(Cnj [f1,f2]) n = (formLength f1 0) + (formLength f2 0) + (n + 2)
formLength f@(Dsj [f1,f2]) n = (formLength f1 0) + (formLength f2 0) + (n + 2)
formLength f@(Impl f1 f2) n = (formLength f1 0) + (formLength f2 0) + (n + 2)
formLength f@(Equiv f1 f2) n = (formLength f1 0) + (formLength f2 0) + (n + 2)

